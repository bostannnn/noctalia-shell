import QtQuick
import QtQuick.Effects
import Quickshell
import qs.Commons

/**
 * ScreenBorder - Draws a colored border around the entire screen
 * 
 * Uses a mask technique from caelestia-dots/shell:
 * 1. Fill the entire screen with the border color
 * 2. Cut out the center (with rounded corners) using a mask
 * 3. Only the border strip remains visible
 * 
 * The border covers from screen edge to bar edge on the bar side,
 * and mirrors that margin on the opposite side for centering.
 */
Item {
  id: root

  // Reference to the bar for proper coverage
  property Item bar: null
  
  // Border configuration from Settings
  property int borderThickness: Settings.data.general.screenBorderThickness ?? 10
  property int borderRounding: Settings.data.general.screenBorderRounding ?? Math.round(25 * Settings.data.general.radiusRatio)
  property color borderColor: (Settings.data.general.screenBorderUseThemeColor ?? true)
                              ? Color.mSurface 
                              : (Settings.data.general.screenBorderColor ?? Color.mSurface)
  property bool enabled: Settings.data.general.screenBorderEnabled ?? false
  
  // Bar position awareness
  property string barPosition: Settings.data.bar?.position ?? "left"

  anchors.fill: parent
  visible: enabled && borderThickness > 0

  // Apply Hyprland gaps on startup and when settings change
  Component.onCompleted: Qt.callLater(updateHyprlandGaps)
  onEnabledChanged: updateHyprlandGaps()
  onBorderThicknessChanged: if (enabled) updateHyprlandGaps()
  onBarPositionChanged: updateHyprlandGaps()

  // Margin from settings
  property int borderMargin: Settings.data.general.screenBorderMargin ?? 10
  onBorderMarginChanged: if (enabled) updateHyprlandGaps()

  // Watch for floating bar changes (affects gaps when screen border is disabled)
  property bool floatingBar: Settings.data.bar?.floating ?? false
  onFloatingBarChanged: if (!enabled) updateHyprlandGaps()

  // Path to generated config file
  readonly property string gapsConfigPath: Settings.configDir + "/hypr-gaps.conf"

  function updateHyprlandGaps() {
    var gapsValue = "0";
    
    if (enabled) {
      // Calculate gap for each side: top, right, bottom, left
      // Use consistent margin on all sides for visual balance
      var margin = borderMargin;
      var barHeight = Style.barHeight || 48;
      
      var top = borderThickness + margin;
      var right = borderThickness + margin;
      var bottom = borderThickness + margin;
      var left = borderThickness + margin;
      
      // Bar side: add bar height so windows are margin away from bar edge
      if (barPosition === "left") {
        left = borderThickness + barHeight + margin;
      } else if (barPosition === "right") {
        right = borderThickness + barHeight + margin;
      } else if (barPosition === "top") {
        top = borderThickness + barHeight + margin;
      } else if (barPosition === "bottom") {
        bottom = borderThickness + barHeight + margin;
      }
      
      // Hyprland gaps_out format: top right bottom left
      gapsValue = top + " " + right + " " + bottom + " " + left;
    } else {
      // When screen border disabled, check if floating bar needs gaps
      var floatingBarGap = (Settings.data.bar?.floating ?? false) ? 10 : 0;
      if (floatingBarGap > 0) {
        var barPos = Settings.data.bar?.position ?? "left";
        var t = floatingBarGap, r = floatingBarGap, b = floatingBarGap, l = floatingBarGap;
        var barSize = (Style.barHeight || 48) + 10;
        if (barPos === "left") l = barSize;
        else if (barPos === "right") r = barSize;
        else if (barPos === "top") t = barSize;
        else if (barPos === "bottom") b = barSize;
        gapsValue = t + " " + r + " " + b + " " + l;
      }
    }
    
    // Write to config file and reload hyprland
    var configContent = "# Auto-generated by Noctalia Screen Border\n# Source this file in your hyprland.conf: source = ~/.config/noctalia/hypr-gaps.conf\ngeneral:gaps_out = " + gapsValue + "\n";
    
    // Write config file
    Quickshell.execDetached(["sh", "-c", "mkdir -p '" + Settings.configDir + "' && echo '" + configContent + "' > '" + gapsConfigPath + "'"]);
    
    // Apply immediately with hyprctl keyword (for instant feedback)
    Quickshell.execDetached(["hyprctl", "keyword", "general:gaps_out", gapsValue]);
  }

  // The colored rectangle that fills the entire screen
  Rectangle {
    id: borderFill
    anchors.fill: parent
    color: root.borderColor

    // Apply color animation for smooth theme transitions
    Behavior on color {
      ColorAnimation {
        duration: Style.animationNormal
        easing.type: Easing.OutQuad
      }
    }

    // Enable layer for mask effect
    layer.enabled: root.enabled
    layer.effect: MultiEffect {
      maskSource: borderMask
      maskEnabled: true
      maskInverted: true  // Invert mask - show only where mask is NOT drawn
      maskThresholdMin: 0.5
      maskSpreadAtMin: 1
    }
  }

  // Mask item - draws the "cutout" area (the screen center)
  Item {
    id: borderMask
    anchors.fill: parent
    layer.enabled: true
    visible: false  // Mask source doesn't need to be visible

    Rectangle {
      id: centerCutout
      
      // Position: inset from all edges
      // On the bar side: cutout starts at bar's far edge (covers bar area)
      // On all other sides: normal border thickness
      anchors.fill: parent
      anchors.margins: root.borderThickness
      
      // Left margin: larger only if bar is on the left
      anchors.leftMargin: {
        if (root.barPosition === "left" && root.bar)
          return root.bar.x + root.bar.width
        return root.borderThickness
      }
      
      // Right margin: larger only if bar is on the right
      anchors.rightMargin: {
        if (root.barPosition === "right" && root.bar)
          return parent.width - root.bar.x
        return root.borderThickness
      }
      
      // Top margin: larger only if bar is on the top
      anchors.topMargin: {
        if (root.barPosition === "top" && root.bar)
          return root.bar.y + root.bar.height
        return root.borderThickness
      }
      
      // Bottom margin: larger only if bar is on the bottom
      anchors.bottomMargin: {
        if (root.barPosition === "bottom" && root.bar)
          return parent.height - root.bar.y
        return root.borderThickness
      }
      
      radius: root.borderRounding
      color: "white"  // Any opaque color works for mask
    }
  }
}
